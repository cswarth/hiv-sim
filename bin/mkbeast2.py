#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
    make a new BEAST  config file by inserting FASTA sequences into a template using the jinja2 package for python

    usage:

         mkbeast.py -p foo template.xml sequences.fasta  >beast_in.xml

    This will take the fasta sequences and insert them into template.xml
    to produce an XML file that is suitable to pass to BEAST.  

    The fasta sequences should have been generated by a simulation or
    from patients.  Each sequence is expected to have a label like

       >patient3_100_2|patient2.fa|400|600

    which is laid out as,

       <sequence identifier>|<parent file>|<parent generation>|<cumulative generation>

    The sequence identifier is further broken up into,
         <prefix>_<generation>_<index>"

    The date of this sequence is calculated as,
         cumulative generation of parent
         + current generation

    Once the BEAST config file is generated, you would run,

         beast beast_in.xml

    This will produce various output files, among which is foo.trees.
    That file gets fed to the 'annotatetrees' program and the output of that gets
    visualized with 'figtree'.
'''

from __future__ import print_function

import jinja2

import re
from Bio import SeqIO
from collections import defaultdict
import getpass
from datetime import datetime, date, timedelta

import sys
import argparse
import os.path

# patients dict stores instance of class Patient keyed by patient
# id string.  we create a new one when we run into a patient id
# string that we haven't seem before.  patient id string is
# derived from the first part of the name on an alignment,
# e.g. 'patient1_100_1' yields patient id 'patient1'
#
patients = defaultdict()

startDate = datetime.strptime("6/13/1994", "%m/%d/%Y").date()

def render(patients, template, fp):
    env = jinja2.Environment(loader=jinja2.FileSystemLoader(searchpath="/"))
    # Alias str.format to strformat in template
    env.filters['strformat'] = str.format
    template = env.get_template(template)
    template.stream(patients=patients,
            date=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            user=getpass.getuser(),
            command=" ".join(sys.argv),
            workdir=os.getcwd()).dump(fp)


    
def processFasta(datafile, generations=None):
    '''
    Read sequences from a FASTA file (datafile) and integrate them into a BEAST config (tree).
    The tree is modified in-place.  
    '''
    # define a regex to extract the generation number from the fasta id string
    # we use this to provide tip dates to BEAST.
    patients = defaultdict(dict)
    
    name_regex = re.compile("(?P<patient>^[^_]*)_(?P<generation>.*)_")

    with open(datafile, "rU") as handle:
    
        # for each fasta sequence in the data file, create a taxon node and a sequence node.
        for record in SeqIO.parse(handle, "fasta") :
            # extract the patient id and generation from the fasta name.
            fields = record.id.split('|')
            match = name_regex.search(fields[0])
            patientId = match.group('patient')

            generationId = match.group('generation')

            # If the user specified '-g' on the command line, only process sequences if they are from one of the
            # specified generations
            #     otherwise, skip to the next entry.

            if generations and int(generationId) not in generations:
                continue
            
            sampleDate = startDate
            sampleDate += timedelta(int(fields[3]))   # each generation is counted as one day!
            sampleDate += timedelta(int(generationId))
            taxon = {}
            taxon["id"] = record.id
            taxon["seq"] = str(record.seq)
            taxon["date"] = sampleDate

            # Create a patient instance if we haven't seen this patient id before
            # REMIND - perhaps better to store as class variable in Patient class?
            patient = patients[patientId]
            if not patient:
                patient['bydate'] = defaultdict(dict)

            collectiondate = (patient['bydate'])[generationId]
            if not collectiondate:
                collectiondate['taxa'] = []
                collectiondate['date'] = sampleDate.strftime('%d/%m/%Y')

            collectiondate['taxa'].append(taxon)


            # >patient3_100_2|patient2.fa|400|600
            #  <sequence identifier>|<parent file>|<parent generation>|<cumulative generation>
            # the date of this sequence is calculated as,
            # 	 cumulative generation of parent
            #  + sampled generation from current patient.
            #

            
    return(patients)



    

def build_parser():
    def commaSplitter(str):
        """
        Argparse a comm-seperated list
        """
        # leave this here as a reminder of what I shold do to make the argument parsing more robust

        # if sqrt != int(sqrt):
        #      msg = "%r is not a perfect square" % string
        #      raise argparse.ArgumentTypeError(msg)
        # return value
        return str.split(',')

    def existing_file(fname):
        """
        Argparse type for an existing file
        """
        if not os.path.isfile(fname):
            raise ValueError("Invalid file: " + str(fname))
        return fname

    parser = argparse.ArgumentParser(description=__doc__)

    parser.add_argument('template', help='templated BEAST XML config'
            )
    parser.add_argument('--fasta', help='produce a FASTA file (default: produce XML file)',
            action='store_true', default=False, dest='createFasta')
    parser.add_argument('--prefix', help='Specify a prefix for all output log filename',
            action='store', default="", dest='prefix')
    parser.add_argument('--generations', help="""Restrict sequences tospecific generations.\n
            May be a comma-seperated list, e.g. 100,800,1000\n
            [default: %(default)s]""", type=commaSplitter, default=[])
    parser.add_argument('datafiles', nargs='*', help='FASTA input', type=existing_file)



    return parser


def main(args=sys.argv[1:]):
    '''
    Parse a generic template and insert sequences from a FASTA file into the middle,
    separated by the appropriate XML tags.
    '''

    parser = build_parser()
    arguments = parser.parse_args()

    prefix = arguments.prefix
    createFasta = arguments.createFasta
    
    datafiles = arguments.datafiles
    generations = [int(x) for x in arguments.generations]

    
    patients = processFasta(datafiles[0], generations)
        
    render(patients, arguments.template, sys.stdout)



    
if __name__ == "__main__":
   main(sys.argv[1:])
   


