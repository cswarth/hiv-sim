#!/usr/bin/python
# make a new BEAST  config file by inserting FASTA sequences into a generic template.
#
# csw 6/3/2014
# The way to use this script:
#
#      mkbeast.py -p foo template.xml sequences.fasta  >beast_in.xml
#
# This will take the fasta sequences and insert them into template.xml
# to produce an XML file that is suitable to pass to BEAST.  
#
# The fasta sequences should have been generated by a simulation or
# from patients.  Each sequence is expected to have a label like
#
#    >patient3_100_2|patient2.fa|400|600
#
# which is laid out as,
#
#    <sequence identifier>|<parent file>|<parent generation>|<cumulative generation>
#
# The sequence identifier is furhter broken up into,
#	 <prefix>_<generation>_<index>"
#
# The date of this sequence is calculated as,
# 	 cumulative generation of parent
#  + current generation
#
# Once the BEAST config file is generated, you would run,
#
#      beast beast_in.xml
#
# This will produce various output files, among which is foo.trees.
# That file gets fed to the 'annotatetrees' program and the output of that gets
# visualized with 'figtree'.
#
from __future__ import print_function

from lxml import etree
import re
from Bio import SeqIO
from collections import defaultdict
from datetime import datetime, date, timedelta

import sys, getopt
import argparse
import os.path

# patients dict stores instance of class Patient keyed by patient
# id string.  we create a new one when we run into a patient id
# string that we haven't seem before.  patient id string is
# derived from the first part of the name on an alignment,
# e.g. 'patient1_100_1' yields patient id 'patient1'
#
patients = defaultdict()

startDate = datetime.strptime("6/13/1994", "%m/%d/%Y")

# indent xml text for pretty-printing
# assumes text within elements is not significant.
def indent(elem, level=0):
    i = "\n" + level*"\t"
    if len(elem):
        if not elem.text or not elem.text.strip():
            elem.text = i + "\t"
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
        for elem in elem:
            indent(elem, level+1)
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i

def beastConfigToFasta(tree):
    '''
    extract seqences and date from a beast config tree and produce annotated fasta sequences.

    This is useful if you want to take the sequences from a best file and run them through beauti while extracting tip dates.

    '''
    
    for s in tree.xpath("/beast/alignment/sequence/taxon"):
        taxonId = s.get("idref")
        xspec = "//taxon[@id='{}']/date".format(taxonId)
        dateref = tree.find(xspec)
        idref = dateref.get("idref")
        xspec = "//date[@id='{}']".format(idref)
        date = tree.find(xspec)
        print(">{}|{}\n{}".format(taxonId, date.get("value"), s.tail))


def processFasta(tree, datafile, generations=None):
    '''
    Read sequences from a FASTA file (datafile) and integrate them into a BEAST config (tree).
    The tree is modified in-place.  
    '''
    # define a regex to extract the generation number from the fasta id string
    # we use this to provide tip dates to BEAST.

    name_regex = re.compile("(?P<patient>^[^_]*)_(?P<generation>.*)_")

    with open(datafile, "rU") as handle:
    
        # for each fasta sequence in the data file, create a taxon node and a sequence node.
        for record in SeqIO.parse(handle, "fasta") :
            # extract the patient id and generation from the fasta name.
            fields = record.id.split('|')
            match = name_regex.search(fields[0])
            patientId = match.group('patient')
            generation = match.group('generation')

            # If the user specified '-g' on the command line, only process sequences if they are from one of the
            # specified generations
            #     otherwise, skip to the next entry.

            if generations is not None and int(generation) not in generations:
                continue
            
            # Create a patient instance if we haven't seen this patient id before
            # REMIND - perhaps better to store as class variable in Patient class?
            if patientId not in patients:
                patients[patientId] = Patient(tree, patientId)
                p = patients[patientId]

            # >patient3_100_2|patient2.fa|400|600
            #  <sequence identifier>|<parent file>|<parent generation>|<cumulative generation>
            # the date of this sequence is calculated as,
            # 	 cumulative generation of parent
            #  + sampled generation from current patient.
            #

            sampleDate = startDate
            sampleDate += timedelta(int(fields[3]))
            sampleDate += timedelta(int(generation))
            p.addSequence(generation, str(record.seq), sampleDate)

def commaSplitter(str):
    """
    Argparse a comm-seperated list
    """
    return str.split(',')

def existing_file(fname):
    """
    Argparse type for an existing file
    """
    if not os.path.isfile(fname):
        raise ValueError("Invalid file: " + str(fname))
    return fname


def build_parser():
    parser = argparse.ArgumentParser(description=__doc__)

    parser.add_argument('beast_xml', help='BEAST XML input',
            type=existing_file)
    parser.add_argument('--fasta', help='produce a FASTA file (default: produce XML file)',
            action='store_true', default=False, dest='createFasta')
    parser.add_argument('--prefix', help='Specify a prefix for all output log filename',
            action='store', default="", dest='prefix')
    parser.add_argument('--generations', help="""Restrict sequences tospecific generations.\n
            May be a comma-seperated list, e.g. 100,800,1000\n
            [default: %(default)s]""", type=commaSplitter, default=[''])
    parser.add_argument('datafiles', nargs='*', help='FASTA input', type=existing_file)

    return parser


def main(args=sys.argv[1:]):
    '''
    Parse a generic template and insert sequences from a FASTA file into the middle,
    separated by the appropriate XML tags.
    '''

    parser = build_parser()
    arguments = parser.parse_args(args)
    prefix = arguments.prefix
    createFasta = arguments.createFasta
    
    templatefile = arguments.beast_xml
    datafiles = arguments.datafiles
    generations = [int(x) for x in arguments.generations]

    tree = etree.parse(templatefile)

    # Eliminate some elements from that tree; we will replace these without own.

    for xspec in [  "/beast/taxa",
                    "/beast/alignment",
                    "/beast/date",
                    "/beast/coalescentSimulator[@id]/coalescentSimulator" ]:
        for e in tree.xpath(xspec):
            e.getparent().remove(e)
        
    # insert some tags right at the top of the XML tree.   These tags will be populated later.
    BeastTaxa(tree, 'taxa')		# add taxa to the tree
    BeastTaxa(tree, 'root')		# add taxa to the tree
    root = tree.getroot()
    root.insert(2, etree.Element("alignment", id='alignment', dataType="nucleotide"))

    # for each fasta sequence in the data file, create a taxon node and a sequence node.
    for datafile in datafiles:
        processFasta(tree, datafile, generations)

        for xspec in [  "/beast/taxa",
                        "/beast/alignment",
                        "/beast/date",
                        "/beast/coalescentSimulator[@id]/coalescentSimulator" ]:
            if not tree.xpath(xspec) :
                print("Tree is missing critical tags - {}". format(xspec), file=sys.stderr)
                sys.exit(2)
            
    # pretty-print the tree
    indent(root)
    
    if createFasta:
        beastConfigToFasta(tree)
    else:
        print(etree.tostring(tree, pretty_print=True))



class BeastTaxa(object):		# new style class inherits from object
    							# which means subclasses can use super()
                                # https://docs.python.org/2/library/functions.html#super
    '''
        Define a class to hold data and methods associated with taxa definitions in
        BEAST config files.

        We usually define two or three kinds of taxa in BEAST config files:

        	global taxa like 'taxa' and 'root',
            per-patient taxa like 'patient1', 
            per-patient,per-generation taxa like 'patient1_200'

        This class is a general BEAST taxa class.  Given a taxa ID it knows
        how to define a taxa, and how to add a taxon reference to the taxa.
        A couple of helper functions for defining and enforcing various constraints
        on taxa are also packaged in this class. 
        This class does NOT know how to define a single taxon - that is done elsewhere.
    '''

    def __init__(self, tree, id):
        self._tree = tree
        self._id = id

        # insert taxa after all existing taxa definitions, or at start of tree if no taxa exist.

        taxa = etree.Element("taxa", id=self._id)
        # Add as next taxa node, or at start of tree if no taxa exist
        current_taxa = tree.xpath('/beast/taxa')
        if current_taxa:
            current_taxa[-1].addnext(taxa)
        else:
            tree.getroot().insert(0, taxa)
            

    def addDate(self, dateId, sampleDate, position=None):
        # dates in the beast config correspond to generations in the
        # santa-sim output.

        if position is None:
            position = 0
            e = self._tree.find("./date[last()]")
            if e is not None:
                position = e.getparent().index(e)
                position += 1
        date = etree.Element("date", id=dateId, value=sampleDate.strftime('%d/%m/%Y'), units="years")
        self._tree.getroot().insert(position, date)


    def addTaxon(self, taxonId, dateId=None):
        # create a taxon tag, embed the date within the taxon,
        if dateId is None:
            xml = ( '<taxon id="{}"/>' ).format(taxonId)
        else:
            xml = ( '<taxon id="{}">'
                    '  <date idref="{}"/>'
                    '</taxon>' ).format(taxonId, dateId)
        xpath = "./taxa[@id='{}']".format(self._id)
        self._tree.find(xpath).append(etree.XML(xml))

    def addTaxonRef(self, taxonId):
        '''
        Append a taxon reference to the per-patient-generation taxa
        '''
        xpath = "./taxa[@id='{}']".format(self._id)
        self._tree.find(xpath).append(etree.Element("taxon", idref=taxonId))

    def monophyly(self):
        # Monitor the monophyly of the specified taxa
        # see http://bodegaphylo.wikispot.org/3._Editing_XML_Input_File#l17
        # http://stackoverflow.com/a/7475897/1135316
        xml = ( '<monophylyStatistic id="monophyly({id})">'
                '<mrca><taxa idref="{id}"/></mrca>'
                '<treeModel idref="treeModel"/>'
                '</monophylyStatistic>' ).format(id=self._id)
        treemodel = self._tree.find(".//treeModel")
        parent = treemodel.getparent()
        parent.insert(parent.index(treemodel)+1, etree.XML(xml))

        # Enforce the monophyly of the specified patient taxa
        prior = self._tree.find(".//mcmc/posterior/prior")
        xml = ( '<booleanLikelihood id="likelihood({id})">\n'
                '<monophylyStatistic idref="monophyly({id})"/>\n'
                '</booleanLikelihood>\n' ).format(id=self._id)
        #prior.append(etree.Comment(etree.tostring(etree.XML(xml))))
        prior.append(etree.XML(xml))

        # Constrain the starting tree to make this taxa monophyletic.

        xspec = "//constantSize[@idref]"
        idref = self._tree.find(xspec).get('idref')
        xml = ( '<coalescentSimulator>'
                '  <taxa idref="{}"/>'
                '  <constantSize idref="{}"/>'
                '</coalescentSimulator>').format(self._id, idref)
        cs = self._tree.find("./coalescentSimulator[@id]")
        cs.append(etree.XML(xml))

    def tmrca(self):
        # Monitor the age of the specified clade
        # http://bodegaphylo.wikispot.org/3._Editing_XML_Input_File#l23
        # http://stackoverflow.com/a/7475897/1135316
        xml = ( '<tmrcaStatistic id="tmrca({patient})">\n'
                '<mrca><taxa idref="{patient}"/></mrca>\n'
                '<treeModel idref="treeModel"/>\n'
                '</tmrcaStatistic>\n' ).format(patient=self._id)
        treemodel = self._tree.find(".//treeModel")
        parent = treemodel.getparent()
        parent.insert(parent.index(treemodel)+1, etree.XML(xml))


    def ancestralTrait(self):
        '''
        Log the ancestral sequences for this taxa.
        '''
        # Log the inferred ancestral sequence of this patient.
        # see http://bodegaphylo.wikispot.org/3._Editing_XML_Input_File#l17
        # http://stackoverflow.com/a/7475897/1135316
        xml = ( '<ancestralTrait name="{patient}"  traitName="states">'
                '<treeModel idref="treeModel"/>'
				'<ancestralTreeLikelihood idref="treeLikelihood"/>'
                '</ancestralTrait>' ).format(patient=self._id)
        node = self._tree.find(".//ancestralTrait[@traitName='states']")
        node.getparent().append(etree.XML(xml))
        


class Generation(BeastTaxa):
    '''
    A class to hold behavior specific to a single generation within a patient.
    It is expected that one generation instance will be created for each unique generation within
    a patient.   Each generation creates a <data> tag in the tree.  Every taxon added through a particular
    generation instance is associated with the date of that generation.
    '''
    
    def __init__(self, tree, generationId, sampleDate):
        super(Generation, self).__init__(tree, generationId)
        self._sindex = 1		# unique index per taxon 

        # each generation in each patient has a unique date.
        dateId = "date("+self._id+")"
        self.addDate(dateId, sampleDate)

        self.tmrca()
        self.monophyly()   # declare each generation to be monophyletic

    # adding a taxon automatically associates the date of the generation with the new taxon.
    #
    def addTaxon(self):
        '''
        Each taxon in a generation is associated with a date derived fro, this generation number.
        '''
        dateId = "date("+self._id+")"
        taxonId = self._id+"_"+str(self._sindex)
        self._sindex += 1

        # add every new taxon to the "taxa' an 'root' taxas as well.
        #

        xml = ( '<taxon id="{}">'
                '  <date idref="{}"/>'
                '</taxon>' ).format(taxonId, dateId)
        xpath = "./taxa[@id='taxa']".format(self._id)
        self._tree.find(xpath).append(etree.XML(xml))

        xml = ( '<taxon idref="{}"/>' ).format(taxonId)
        xpath = "./taxa[@id='root']".format(self._id)
        self._tree.find(xpath).append(etree.XML(xml))

        super(Generation,self).addTaxonRef(taxonId)
        return(taxonId)


# define a patient class.  I would have preferred to make this a
# subclass of etree._Element, but I couldn't get that to work.
class Patient(BeastTaxa):
    def __init__(self, tree, patientid):
        super(Patient, self).__init__(tree, patientid)

        self._generations = defaultdict()
        
        self.ancestralTrait()


    def addSequence(self, generation, sequence, sampleDate):
        '''
        the tag has format
        >patient2_100_1 patient1 200 6/13/1995
        '''
        generationId = self._id+"_"+generation
        # Create a generation instance if we haven't seen this generation id before
        if generationId not in self._generations:
            self._generations[generationId] = Generation(self._tree, generationId, sampleDate)
        g = self._generations[generationId]

        taxonId = g.addTaxon()
        self.addTaxonRef(taxonId)
        

        # Create a <sequence> with refid to appropriate <taxon>
        #
        xml = ( '<sequence>'
                '  <taxon idref="{id}"/>'
                '  {sequence}'
                '</sequence>' ).format(id=taxonId, sequence=str(sequence))
        self._tree.find("./alignment").append(etree.XML(xml))




    
if __name__ == "__main__":
   main(sys.argv[1:])
   


