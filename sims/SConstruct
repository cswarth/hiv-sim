#!/usr/bin/env scons
# -*- coding: utf-8 -*-

''' 

Scons file for driving Nestly to create a hierachy of directories
and control files that can explore various paramter settings of Santa
and BEAST.

The main idea is to have a hierarchy of directories that vary the
branch lengths of simulated sibling HIV clades.  In addition for each
pair of siblings, we want to vary BEAST parameters to explore the
effect of various evolutionary clock models on the inferrence of
ancestral sequences.

We start with a single sequence fro mwhich we simulat multiple
generations of HIV evolution.  We sample this evolutionaery history at
a certain timepoint, say at generation 400, to create patient1.  Then
we sample the same evolutionary history at a several different
timepoints, say 100, 500, 1000, and 10000 generations, to create
patient2.  Next we create a BEAST configuration that combines the
samples from patient1 ad patient2 and ask it to infer the ancestral
sequence at the MRCA of these sequences.

'''



# Simulations for lcfit
import os
import os.path

from nestly import Nest
from nestly.scons import SConsWrap
from SCons.Script import Environment

environ = os.environ.copy()

for k in ('SLURM_NTASKS', 'SLURM_NPROCS', 'SLURM_NNODES',
          'SLURM_NTASKS_PER_CORE', 'SLURM_CPUS_PER_TASK', 'SLURM_EXCLUSIVE'):
    environ[k] = '1'
environ['SLURM_TIMELIMIT'] = '0-6'

env = Environment(ENV=environ)
env.PrependENVPath('PATH', '../bin')

n = Nest(base_dict={'n_sites': 1000})
w = SConsWrap(n, 'runs', alias_environment=env)

env['SANTAJAR']= os.path.abspath('../lib/santa.jar')

# maximum number of generations to run a simulation.
env['LONGEVITY'] = 25000
env['POPULATION'] = 1000

### Add to PATH
### We're going to simulate a call to 'source venv/bin/activate' by adding
### 'venv/bin' to the head of the path.
# if you don't have a virtual environment yet, you can build it with 'make venv'
env['venv'] = '../venv'
env.PrependENVPath('PATH', os.path.join(env['venv'], 'bin'))

# build the HIV evolutionary history from which we will sample
# the patient #1
donorsantaconfig = env.Command("donor_santa_config.xml",
                       ['../templates/santa_template.xml', '../hiv_pol.fa'],
                       "mksanta.py  -p patient1 ${SOURCES}   >${TARGET}")[0]

donorlineage = env.Command("donorlineage.fa",
                        [ donorsantaconfig, env['SANTAJAR'] ],
                        [ "srun --output=srun.log java -jar ${SANTAJAR} -population=${POPULATION} -longevity=${LONGEVITY} ${SOURCES[0]}  && mv santa_out.fa ${TARGET} " ])[0]


# Sample the right host at various
# timepoints along its evolution

# for each right sister clades,
# infer ancestral sequence in two ways - 1) by including the left sister clade, and 2) by inferring over just the right sister clade.

# estimate distance from each inferred sequence to actual root sequence.

# n.add('transmission', [100, 300, 500, 700, 1000, 5000, 10000])
n.add('transmission', [300, 700])

## Extract the founder sequence from the santa config file into a FASTA file.
## This makes it easier for the distance.py script to grab it for comparison.
@w.add_target_with_env(env)
def founder(env, outdir, c):
    founder = os.path.join(outdir, 'founder.fa')
    cmd = ('../bin/fasta_sample.py --fasta-file ${SOURCES[0]} --n-sequences 1 --pattern "_${transmission}_" >${TARGET}')

    return env.Command(founder,
                [ donorlineage ],
                [ cmd ])


## Create the SANTA config file to found a lineage based on a single sequence selected from the 'transmission' generation of the
## donor lineage.
@w.add_target_with_env(env)
def recipientconfig(env, outdir, c):
    target = os.path.join(outdir, 'recipientconfig.xml')
    return env.Command(target,
                       ['../templates/santa_template.xml', c['founder']],
                       # usage: mksanta -p <prefix> <template_file> <sequences_file>    <#founders>
                       "mksanta.py  -p patient2 ${SOURCES}  >${TARGET}")


## Run SANTA to generate the right-hand lineage based on the 'rightconfig' configuration file created above.
@w.add_target_with_env(env)
def recipientlineage(env, outdir, c):
    target = os.path.join(outdir, 'santa_out.fa')
    config = os.path.abspath(str(c['recipientconfig']))
    env['PWD'] = os.getcwd()

    return env.Command(target,
                [ c['recipientconfig'], env['SANTAJAR'] ],
                [ "cd ${TARGET.dir} && srun --output=srun.log java -jar ${SANTAJAR} -population=${POPULATION} -longevity=${LONGEVITY} ${PWD}/${SOURCES[0]}"])[0]



# calculate timepoints (generations), relative to transmission event, at which to sample the donor after the transmisson event.

# Goint into the routine, we have already created a donor lineage for some large number of
# generations
#
# Start with a geometric series of timepoints [a*(r^i) for i in 0..9].
# Constrain these values to fall on 100-generation boundaries where the lineage has been previously sampled.
# Cutoff the series at the maximum longevity.
# Finally add in a couple of special timepoints at the beginning.
#
# If tranmission happens at 700, and 
def calculate_donor_timepoints(c):
    a=100
    r=2.5
    series = [a*pow(r,i) for i in range(0,10)]
    series = [int(round(v/100)*100) for v in series]
    samples = list(set([min(t, env['LONGEVITY']-c['transmission']) for t in series]))
    samples =  [ "nodonor", 0 ] + samples
    return(samples)

# donor time since transmission
n.add('donor_time_since_transmission', calculate_donor_timepoints)

def calculate_recipient_timepoints(c):
    a=100
    r=2.5
    geom_series = [int(round(a*pow(r,i)/100)*100) for i in range(0,10)]
    samples = [min(t, env['LONGEVITY']) for t in geom_series]
    samples = list(set(samples))
    return(samples)
    
n.add('recipient_time_since_transmission', calculate_recipient_timepoints)


# For each data set, we evaluated both strict and relaxed uncorrelated lognormal clock models.
# These are captured in the different template files used to build the BEAST configs.
#
# See: McCloskey, R. M., Liang, R. H., Harrigan, P. R., Brumme, Z. L.,
# & Poon, A. F. Y. (2014). An Evaluation of Phylogenetic Methods for
# Reconstructing Transmitted HIV Variants using Longitudinal Clonal
# HIV Sequence Data. Journal of Virology, 88(11),
# 6181â€“94. doi:10.1128/JVI.00483-14

n.add('clock_model', ['relaxed'])	# 'strict'


# Create a multiple alingment from the sampled sequences.
# Note you don't hve to do this if all the sequences are the same length, but
# when inels are involved, you have to align them before caling beast.
# create_maf = create multiple alignment file

# oh shit, the sampling of sequences is part of the script that builds the beast config file!
# dumb, dumb, dumb!  I'll have to separate these...
@w.add_target_with_env(env)
def donor_sample(env, outdir, c):
    target = os.path.join(outdir, 'donor.fasta')
    
    if env['donor_time_since_transmission'] != "nodonor":
        cmd = ('../bin/fasta_sample.py --fasta-file ${SOURCES[0]} --n-sequences 10 --pattern "_${donor_time_since_transmission}_" >${TARGET}')
    else:
        cmd = ('>${TARGET}')

    return env.Command(target,
                       [ donorlineage],
                       cmd)


@w.add_target_with_env(env)
def recipient_sample(env, outdir, c):
    target = os.path.join(outdir, 'recipient.fasta')
    
    cmd = ('../bin/fasta_sample.py --fasta-file ${SOURCES[0]} --n-sequences 10 --pattern "_${recipient_time_since_transmission}_" >${TARGET}')

    return env.Command(target,
                       [ c['recipientlineage'] ],
                       cmd)

@w.add_target_with_env(env)
def multiple_alignment(env, outdir, c):
    target = os.path.join(outdir, 'sequences.maf')
    
    cmd = ('cat ${SOURCES} | muscle -quiet -out ${TARGET}')

    return env.Command(target,
                       [ c['donor_sample'], c['recipient_sample'] ],
                       cmd)


# create the BEAST config file from sequences extracted from two patient simulations
@w.add_target_with_env(env)
def config_beast(env, outdir, c):
    target = os.path.join(outdir, 'beast_in.xml')
        
    cmd = ("mkbeast.py  --template  ${SOURCES[0]} ${SOURCES[1]}  >${TARGET}")

    return env.Command(target,
                       [ '../templates/${clock_model}-clock.xml', c['multiple_alignment']],
                       cmd)


@w.add_target_with_env(env)
def runbeast(env, outdir, c):
    target = [ os.path.join(outdir, 'ancestralSequences.log'),
               os.path.join(outdir, 'beastout.log'),
               os.path.join(outdir, 'beastout.trees'),
               os.path.join(outdir, 'beastcmd.log') ]
    return env.Command(target,
                       c['config_beast'],
                       "srun --output=srun.log beast -working -overwrite -beagle " + os.path.abspath(str(c['config_beast'][0])) + " >${TARGETS[3]} 2>&1 ")

@w.add_target_with_env(env)
def mcc(env, outdir, c):
    return env.Command(os.path.join(outdir, 'mcc.tree'),
                        c['runbeast'][2],
                       'treeannotator ${SOURCES} | nexus2newick.py | tr -d "\047" >${TARGET} ')


@w.add_target_with_env(env)
def runprank(env, outdir, c):
    target = os.path.join(outdir, 'prank.best.anc.fas')
    env['output'] = os.path.join(outdir, 'prank')
    cmd = ("prank -d=${SOURCES[0]} -t=${SOURCES[1]} -o=${output} -once -f=fasta -showanc -showtree -showevents -DNA ")
    return env.Command(target,
                       [ c['multiple_alignment'], c['mcc'] ],
                       cmd)


# @w.add_target_with_env(env)
# def beast_distance(env, outdir, c):
#     detail = os.path.join(outdir, 'beast_distance.csv')
#     return env.Command([detail], 
#                        [c['founder'], c['runbeast'][0]],
#                        "distance.py  ${SOURCES} >${TARGETS[0]} ")[0]

# aggregate the individual summary distance files into one single file
# env.Command(['distances.csv'],
#     [i['distance'] for _, i in w],
#     'aggregate_distance.r ${SOURCES} >${TARGET}')
